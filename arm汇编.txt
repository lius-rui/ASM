１、ARM汇编常用条件码助记符
	EQ	      相等									LS       无符号数小于等于
	NE	      不相等									GE       带符号数大于等于
	CS/HS  	  无符号数大于/等于						LT 		 带符号数小于
	CC/LO     无符号数小于							GT 		 带符号数大于
	MI		  负数									LE 		 带符号数小于等于
	PL		　　非负数									AL       无条件执行
	VS        上溢出									NV       该指令从不执行
	VC　　　　　　　　没有上溢出
	HI        无符号数大于

２、ARM指令寻址方式
	立即数寻址：　　MOV  R2, #0xf3 ;寄存器R2的值为0xf3
	寄存器寻址：　　ADD  R0,R1,R2  ;R0 = R1 + R2
	寄存器移位寻址方式：
	ASR   算术右移
	LSL   逻辑左移
	LSR   逻辑右移
	ROR   循环右移
	RRX　　　扩展的循环右移
	eg: 
	MOV R0,R1,LSL #3      ;  R0 = R1 * (2^3)
	ADD R0,R1,R1,LSL #3   ;  R0 = R1 + R1 * (2^3)
	SUB R0,R1,R2,LSR #4   ;  R0 = R1 - R2 /(2^4)
	MOV R0,R1,ROR  R2     ;  R0 = R1循环右移Ｒ２位
	
	Load/Store指令寻址方式：
	Load用于从内存中读取数据放入寄存器中。
	Store用于从寄存器中读取数据保存到内存中。
	LDR    用于从内存中将一个字的数据传送到寄存器中。
３、ARM常用指令集合
	跳转指令：ARM跳转指令可以从当前指令向前或向后的32Ｍ地址空间跳转。
        Ｂ　  跳转指令
	BL   带返回的跳转指令
	BX   带状态切换的跳转指令
　　　    　BLX  带返回和状态切换的跳转指令s
	数据处理指令：数据处理指令大致分为３类，数据传送指令，算术逻辑运算指令，比较指令。
	MOV   数据传送指令
	MVN   数据求反传送指令
　　　　    CMP　　　比较指令
	CMN   基于相反数的比较指令
	TST   位测试指令
	TEQ   相等测试指令
　　　　    ADD   加法指令
　　　　    SUB   减法指令
        RSB   逆向减法指令
        ADC   带位加法指令
　　　　    SBC   带位减法指令
　　　　    RSC   带位逆向减法指令
	AND   逻辑与操作指令
　　　　    BIC   位清除指令
　　　　    EOR   逻辑异或操作指令
　　　     ORR   逻辑或操作指令
　　　    　MUL   32位乘法指令　　　　　   MUL  R0,R1,R2       ;R0 = R1 * R2
　　　　    MLA   32位带加数的乘法指令     MLA  R0,R1,R2,R3    ;R0 = R1 * R2 + R3
　　　　    SMULL 64位有符号数乘法指令		SMULL R0,R1,R2,R3    ; R0 = R2*R3 //低32位
													   R1 = R2*R3 //高32位			
　　　　    SMLAL 64位带加数的有符号数乘法指令
　　　　    UMULL 64位无符号数乘法指令
　　　　    UMLAL 64位带加数的无符号数乘法指令
        CLZ   前导０个数计算指令
        状态寄存器访问指令：ARM中有两条指令用于在状态寄存器和通用寄存器之间传送数据
	MRS    状态寄存器到通用寄存器的传送指令
　　　　    MSR    通用寄存器到状态寄存器的传送指令
　　　　    MRS  R0,CPSR          ;读取CPSR到R0寄存器
        BIC  R0,R0,#0x1F      ;修改，去除当前处理器模式
	ORR  R0,R0,#0x13      ;修改，设置特权模式
        MSR  CPSR_c,R0        ;写回，仅仅修改CPSR中的控制位域
	Load/Store内存访问指令
	LDR        字数据读取指令　　　　　　　　LDR     R0,[R1,#4]    ;将内存单元R1+4中的字读取到R0寄存器中
　　　　    LDRB       字节数据读取指令            LDRB    R0,[R1]       ;将内存单元(R1)中的字节数据读取到R0中,R0中高24位设置成了０
　　　　    LDRBT      用户模式的字节数据读取指令
　　　　    LDRH       半字数据读取指令            LDRH    R0,[R1]       ;将内存单元(R1)中的字节数据读取到R0中,R0中高16位设置成了０
	LDRSB      有符号的字节数据读取指令     LDRSB   R0,[R1,#3]    ;将内存单元(R1+3)中的有符号字节数据读取到R0中，R0中高24位设置成该字节数据的符号位
　　　　    LDRSH      有符号的半字数据读取指令     LDRSH   R0,[R1,#3]    ;将内存单元(R1+3)中的有符号字节数据读取到R0中，R0中高16位设置成该字节数据的符号位
　　　　    LDRT       用户模式的字数据读取指令
　　　　    STR        字数据写入指令				 STR     R0,[R1,#0x100]   ;将R0中的自数据保存到内存单元(R1 + 0x100)中
　　　　    STRB       字节数据写入指令            STRB    R3,[R5,#0x200]   ;将R3中的低８位数据保存到内存地址(R5+0x200)中
        STRBT      用户模式下字节数据写入指令
　　　　    STRH       半字数据写入指令
　　　　    STRT       用户模式下字数据写入指令
	批量Load/Store内存访问指令：批量Load/Store内存访问指令可以一次从连续的内存单元中读取数据，传送到指令中的内存列表中的各个寄存器中,同时也可以将指令中寄存器列表中的各个寄存器值写入到内存中。
	LDM(1)     批量内存字数据读取指令
　　　　    LDM(2)     用户模式下的批量内存字数据读取指令
　　　　    LDM(3)     带状态寄存器的批量内存字数据读取指令
　　　　    STM(1)     批量内存字数据写入指令
　　　　    STM(2)　　　　　用户模式下的批量内存字数据写入指令
　　      信号量操作指令：
　　　　    SWP        交换指令     SWP R1,R2,[R3]   ;将内存单元(R3)中字数据读取到R1寄存器中，同时将R2寄存器的数据写入到内存单元(R3)中
        SWPB       字节交换指令
        异常中断产生指令：
	SWI(软中断指令)：用于产生软中断。
	BKPT：断点中断指令，用于产生软件断点中断。
４、ARM协处理器指令
	CDP       协处理器数据操作指令
　　　　    LDC       协处理器数据读取指令
　　　　    STC       协处理器数据写入指令
　　　　    MCR       ARM寄存器到协处理器寄存器的数据传送指令
　　　　    MRC       协处理器寄存器到ARM寄存器的数据传送指令
5、符号定义伪操作:用于定义ARM汇编程序中的变量，对变量进行赋值以及定义寄存器名称
	GBLA,GBLL及GBLS　　声明全局变量
	LCLA,LCLL及LCLS　　声明局部变量
	SETA,SETL及SETS　　给变量赋值
	RLIST    为通用寄存器列表定义名称
	CN       为协处理器的寄存器定义名称
	CP　　　　　　　为协处理器定义名称
	DN,SN　　　　为VFP的寄存器定义名称
　　　　	FN       为FPA的浮点寄存器定义名称
	eg1: 
	   GBLA  objectsize           ; 声明一个全局的算术变量
	   objectsize  SETA  0xff     ;向该变量赋值为0xff ==> objectsize = 0xff
	   SPACE objectsize           ;引用该变量
	eg2:
	   局部变量的作用范围为包含该局部变量的宏代码的一个实例。
	　　　MACRO                  ;声明一个宏
	   $label  message  $a    ;宏的原型
	　　　LCLS err               ;声明一个局部字符串变量 
           err SETS  "error no:"  ;向该局部变量赋值
	　　　$label                 ;代码
           INFO 0,"err":CC::STR:$a ;使用该串变量
	   MEND                    ;宏定义结束　
6、数据定义伪操作
	LTORG        声明一个数据缓冲池的开始
　	MAP          定义一个结构化的内存表的首地址
	FIELD　　　　　　　　定义结构化的内存表中的一个数据域
	SPACE        分配一块内存单元，并用０初始化
	DCB          分配一段字节的内存单元，并用指定的数据初始化 
	DCD,DCDU     分配一段字的内存单元，并用指定的数据初始化
	DCDO         分配一段字的内存单元，并将个单元的内容初始化成该单元相对于静态基值寄存器的偏移量
	DCFD,DCFDU   分配一段双字的内存单元，并用双精度的浮点数据初始化
	DCFS,DCFSU   分配一段字的内存单元，并用单精度的浮点数据初始化
	DCI          分配一段字节的内存单元，用指定的数据初始化，指定内存中存放的代码而不是数据
	DCQ,DCQU　　　　　分配一段双字的内存单元，并用指定的数据初始化
	DCW及DCWU　　　　分配一段半字的内存单元，并用指定的数据初始化
	DATA         在代码段中使用数据，现在已经不在使用，用于向前兼容	
７、汇编控制伪操作
	IF,ELSE及ENDIF 
  	WHILE,WEND
	MACRO,MEND
	MEXIT 　　　用于从宏代码中跳转出去
８、各种杂类伪操作
	CODE16,CODE32   告诉编译器后面的指令序列为１６位Thumb指令还是32位ARM指令
	EQU     	作为数字常量、基于寄存器的值和程序中的标号(基于ＰＣ的值)定义一个字符名称，*是EQU的同义词　　　abcd EQU 2  ;定义abcd符号的值为2，相当于#define
	AREA		用于定义一个代码段或者数据段
	ENTRY           伪操作指定程序的入口点
	END		告诉编译器已经到了源程序结尾
	ALIGN 		通过添加补丁字节使当前位置满足一定的对其方式
	EXPORT		声明一个符号可以被其他文件引用，相当于声明全局变量，类似GLOBAL
	IMPORT		告诉编译器当前的符号不是再本源文件中定义的，而是再其他源文件中定义的
	GET		将一个源文件包含到当前源文件中，并将被包含的文件再其当前位置进行汇编处理，类似ＩＮＣＬＵＤＥ
	INCBIN		将一个文件包含到当前源文件中，被包含的文件不进行汇编处理
	KEEP		告诉编译器将局部符号包含在目标文件的符号表中
	NOFP		禁止源程序中包含浮点运算指令
	REQUIRE		指定段之间的相互依赖关系
	RN		用于给一个寄存器定义名称，方便记忆功能
	ROUT 		作用于定义局部变量的有效范围
9、ARM汇编伪指令
	ADR		将基于PC的地址值或基于寄存器的地址值读取到寄存器中。(小范围的地址读取伪指令)
	ADRL		中等范围的地址读取伪指令
	LDR		大范围的地址读取伪指令
	NOP		空操作伪指令
10、ARM汇编语言语句格式
	｛symbol｝ {instruction | directive | pseudo-instruction} {;comment}
	 instruction为指令，在ARM汇编中，指令不能从一行的行头开始，在一行语句中，指令的前面必须有空格或者符号
	　directive 为伪操作
	 pesudo-instruction为伪指令
	 symbol为符号，符号必须从一行的行头开始，并且不能包含空格，在指令和伪指令中符号用作地址标号(label)，有些伪操作中符号用作变量或者常量
	 comment为注释
		

